package flow

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/nyaruka/goflow/envs"
	"github.com/nyaruka/goflow/flows"
	"github.com/nyaruka/goflow/i18n"
	"github.com/nyaruka/goflow/utils"
	"github.com/nyaruka/goflow/utils/uuids"
	"github.com/nyaruka/mailroom/goflow"
	"github.com/nyaruka/mailroom/models"
	"github.com/nyaruka/mailroom/web"

	"github.com/Masterminds/semver"
	"github.com/go-chi/chi/middleware"
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
)

func init() {
	web.RegisterJSONRoute(http.MethodPost, "/mr/flow/migrate", web.RequireAuthToken(handleMigrate))
	web.RegisterJSONRoute(http.MethodPost, "/mr/flow/inspect", web.RequireAuthToken(handleInspect))
	web.RegisterJSONRoute(http.MethodPost, "/mr/flow/clone", web.RequireAuthToken(handleClone))
	web.RegisterRoute(http.MethodPost, "/mr/flow/po_export", handlePOExport)
}

// Migrates a flow to the latest flow specification
//
//   {
//     "flow": {"uuid": "468621a8-32e6-4cd2-afc1-04416f7151f0", "action_sets": [], ...},
//     "to_version": "13.0.0"
//   }
//
type migrateRequest struct {
	Flow      json.RawMessage `json:"flow" validate:"required"`
	ToVersion *semver.Version `json:"to_version"`
}

func handleMigrate(ctx context.Context, s *web.Server, r *http.Request) (interface{}, int, error) {
	request := &migrateRequest{}
	if err := utils.UnmarshalAndValidateWithLimit(r.Body, request, web.MaxRequestBytes); err != nil {
		return errors.Wrapf(err, "request failed validation"), http.StatusBadRequest, nil
	}

	// do a JSON to JSON migration of the definition
	migrated, err := goflow.MigrateDefinition(request.Flow, request.ToVersion)
	if err != nil {
		return errors.Wrapf(err, "unable to migrate flow"), http.StatusUnprocessableEntity, nil
	}

	// try to read result to check that it's valid
	_, err = goflow.ReadFlow(migrated)
	if err != nil {
		return errors.Wrapf(err, "unable to read migrated flow"), http.StatusUnprocessableEntity, nil
	}

	return migrated, http.StatusOK, nil
}

// Inspects a flow, and returns metadata including the possible results generated by the flow,
// and dependencies in the flow. If `validate_with_org_id` is specified then the cloned flow
// will be validated against the assets of that org.
//
//   {
//     "flow": { "uuid": "468621a8-32e6-4cd2-afc1-04416f7151f0", "nodes": [...]},
//     "org_id": 1
//   }
//
type inspectRequest struct {
	Flow              json.RawMessage `json:"flow" validate:"required"`
	OrgID             models.OrgID    `json:"org_id"`
	ValidateWithOrgID models.OrgID    `json:"validate_with_org_id"` // backwards compatibility
}

func handleInspect(ctx context.Context, s *web.Server, r *http.Request) (interface{}, int, error) {
	request := &inspectRequest{}
	if err := utils.UnmarshalAndValidateWithLimit(r.Body, request, web.MaxRequestBytes); err != nil {
		return errors.Wrapf(err, "request failed validation"), http.StatusBadRequest, nil
	}

	// TODO switch RapidPro to use org_id and remove this
	if request.ValidateWithOrgID != models.NilOrgID {
		request.OrgID = request.ValidateWithOrgID
	}

	flow, err := goflow.ReadFlow(request.Flow)
	if err != nil {
		return errors.Wrapf(err, "unable to read flow"), http.StatusUnprocessableEntity, nil
	}

	var sa flows.SessionAssets
	// if we have an org ID, create session assets to look for missing dependencies
	if request.OrgID != models.NilOrgID {
		org, err := models.GetOrgAssetsWithRefresh(ctx, s.DB, request.OrgID, models.RefreshFields|models.RefreshGroups|models.RefreshFlows)
		if err != nil {
			return nil, 0, err
		}
		sa = org.SessionAssets()
	}

	return flow.Inspect(sa), http.StatusOK, nil
}

// Clones a flow, replacing all UUIDs with either the given mapping or new random UUIDs.
// If `validate_with_org_id` is specified then the cloned flow will be validated against
// the assets of that org.
//
//   {
//     "dependency_mapping": {
//       "4ee4189e-0c06-4b00-b54f-5621329de947": "db31d23f-65b8-4518-b0f6-45638bfbbbf2",
//       "723e62d8-a544-448f-8590-1dfd0fccfcd4": "f1fd861c-9e75-4376-a829-dcf76db6e721"
//     },
//     "flow": { "uuid": "468621a8-32e6-4cd2-afc1-04416f7151f0", "nodes": [...]}
//   }
//
type cloneRequest struct {
	DependencyMapping map[uuids.UUID]uuids.UUID `json:"dependency_mapping"`
	Flow              json.RawMessage           `json:"flow" validate:"required"`
}

func handleClone(ctx context.Context, s *web.Server, r *http.Request) (interface{}, int, error) {
	request := &cloneRequest{}
	if err := utils.UnmarshalAndValidateWithLimit(r.Body, request, web.MaxRequestBytes); err != nil {
		return errors.Wrapf(err, "request failed validation"), http.StatusBadRequest, nil
	}

	// try to clone the flow definition
	cloneJSON, err := goflow.CloneDefinition(request.Flow, request.DependencyMapping)
	if err != nil {
		return errors.Wrapf(err, "unable to read flow"), http.StatusUnprocessableEntity, nil
	}

	// read flow to check that cloning produced something valid
	_, err = goflow.ReadFlow(cloneJSON)
	if err != nil {
		return errors.Wrapf(err, "unable to clone flow"), http.StatusUnprocessableEntity, nil
	}

	return cloneJSON, http.StatusOK, nil
}

// Exports a PO file from the given set of flows.
//
//   {
//     "org_id": 123,
//     "flow_ids": [123, 354, 456],
//     "language": "spa",
//     "exclude_arguments": true
//   }
//
type poExportRequest struct {
	OrgID            models.OrgID    `json:"org_id"  validate:"required"`
	FlowIDs          []models.FlowID `json:"flow_ids" validate:"required"`
	Language         envs.Language   `json:"language" validate:"omitempty,language"`
	ExcludeArguments bool            `json:"exclude_arguments"`
}

func handlePOExport(ctx context.Context, s *web.Server, r *http.Request, rawW http.ResponseWriter) error {
	request := &poExportRequest{}
	if err := utils.UnmarshalAndValidateWithLimit(r.Body, request, web.MaxRequestBytes); err != nil {
		return errors.Wrapf(err, "request failed validation")
	}

	flows, err := loadFlows(ctx, s.DB, request.OrgID, request.FlowIDs)
	if err != nil {
		return err
	}

	var excludeProperties []string
	if request.ExcludeArguments {
		excludeProperties = []string{"arguments"}
	}

	po, err := i18n.ExtractFromFlows("Generated by mailroom", request.Language, excludeProperties, flows...)
	if err != nil {
		return errors.Wrapf(err, "unable to extract PO from flows")
	}

	w := middleware.NewWrapResponseWriter(rawW, r.ProtoMajor)
	w.Header().Set("Content-type", "text/x-gettext-translation")
	w.WriteHeader(http.StatusOK)
	po.Write(w)
	return nil
}

func loadFlows(ctx context.Context, db *sqlx.DB, orgID models.OrgID, flowIDs []models.FlowID) ([]flows.Flow, error) {
	// grab our org
	org, err := models.GetOrgAssets(ctx, db, orgID)
	if err != nil {
		return nil, errors.Wrapf(err, "unable to load org assets")
	}

	flows := make([]flows.Flow, len(flowIDs))
	for i, flowID := range flowIDs {
		dbFlow, err := org.FlowByID(flowID)
		if err != nil {
			return nil, errors.Wrapf(err, "unable to load flow with ID %d", flowID)
		}

		flow, err := org.SessionAssets().Flows().Get(dbFlow.UUID())
		if err != nil {
			return nil, errors.Wrapf(err, "unable to read flow with UUID %s", string(dbFlow.UUID()))
		}

		flows[i] = flow
	}
	return flows, nil
}
