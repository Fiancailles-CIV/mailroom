package models

import (
	"context"
	"encoding/json"
	"fmt"
	"path"
	"slices"
	"time"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	dytypes "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	s3types "github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/nyaruka/gocommon/aws/s3x"
	"github.com/nyaruka/gocommon/dates"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/gocommon/jsonx"
	"github.com/nyaruka/gocommon/stringsx"
	"github.com/nyaruka/goflow/assets"
	"github.com/nyaruka/mailroom/runtime"
	"github.com/nyaruka/mailroom/utils/clogs"
)

// ChannelLogID is our type for a channel log id
type ChannelLogID int64

type ChannelLogType string

const (
	ChannelLogTypeIVRStart    = "ivr_start"
	ChannelLogTypeIVRIncoming = "ivr_incoming"
	ChannelLogTypeIVRCallback = "ivr_callback"
	ChannelLogTypeIVRStatus   = "ivr_status"
	ChannelLogTypeIVRHangup   = "ivr_hangup"
)

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	uuid      clogs.LogUUID
	type_     ChannelLogType
	channel   *Channel
	httpLogs  []*httpx.Log
	errors    []*clogs.LogError
	createdOn time.Time
	elapsed   time.Duration

	recorder *httpx.Recorder
	redactor stringsx.Redactor
	attached bool
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t ChannelLogType, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t ChannelLogType, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t ChannelLogType, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		uuid:      clogs.NewLogUUID(),
		type_:     t,
		channel:   ch,
		httpLogs:  []*httpx.Log{},
		errors:    []*clogs.LogError{},
		createdOn: dates.Now(),

		recorder: r,
		redactor: stringsx.NewRedactor("**********", redactVals...),
	}
}

func (l *ChannelLog) UUID() clogs.LogUUID { return l.uuid }

func (l *ChannelLog) HTTP(t *httpx.Trace) {
	l.httpLogs = append(l.httpLogs, l.traceToLog(t))
}

func (l *ChannelLog) Error(err error) {
	l.errors = append(l.errors, clogs.NewLogError("", "", err.Error()))
}

func (l *ChannelLog) End() {
	if l.recorder != nil {
		// prepend so it's the first HTTP request in the log
		l.httpLogs = append([]*httpx.Log{l.traceToLog(l.recorder.Trace)}, l.httpLogs...)
	}

	l.elapsed = time.Since(l.createdOn)
}

func (l *ChannelLog) traceToLog(t *httpx.Trace) *httpx.Log {
	return httpx.NewLog(t, 2048, 50000, l.redactor)
}

// if we have an error or a non 2XX/3XX http response then log is considered an error
func (l *ChannelLog) isError() bool {
	if len(l.errors) > 0 {
		return true
	}

	for _, l := range l.httpLogs {
		if l.StatusCode < 200 || l.StatusCode >= 400 {
			return true
		}
	}

	return false
}

const sqlInsertChannelLog = `
INSERT INTO channels_channellog( uuid,  channel_id,  log_type,  http_logs,  errors,  is_error,  elapsed_ms,  created_on)
                         VALUES(:uuid, :channel_id, :log_type, :http_logs, :errors, :is_error, :elapsed_ms, :created_on)
  RETURNING id`

// channel log to be inserted into the database
type dbChannelLog struct {
	ID        ChannelLogID    `db:"id"`
	UUID      clogs.LogUUID   `db:"uuid"`
	ChannelID ChannelID       `db:"channel_id"`
	Type      ChannelLogType  `db:"log_type"`
	HTTPLogs  json.RawMessage `db:"http_logs"`
	Errors    json.RawMessage `db:"errors"`
	IsError   bool            `db:"is_error"`
	ElapsedMS int             `db:"elapsed_ms"`
	CreatedOn time.Time       `db:"created_on"`
}

// channel log to be written to logs storage
type stChannelLog struct {
	UUID        clogs.LogUUID      `json:"uuid"`
	Type        ChannelLogType     `json:"type"`
	HTTPLogs    []*httpx.Log       `json:"http_logs"`
	Errors      []*clogs.LogError  `json:"errors"`
	ElapsedMS   int                `json:"elapsed_ms"`
	CreatedOn   time.Time          `json:"created_on"`
	ChannelUUID assets.ChannelUUID `json:"-"`
}

func (l *stChannelLog) path() string {
	return path.Join("channels", string(l.ChannelUUID), string(l.UUID[:4]), fmt.Sprintf("%s.json", l.UUID))
}

// InsertChannelLogs writes the given channel logs to the db
func InsertChannelLogs(ctx context.Context, rt *runtime.Runtime, logs []*ChannelLog) error {
	// write in batches to DynamoDB
	for batch := range slices.Chunk(logs, 25) {
		writeReqs := make([]dytypes.WriteRequest, len(batch))

		for i, l := range batch {
			dl := clogs.NewDynamoChannelLog(l.UUID(), string(l.type_), l.httpLogs, l.errors, l.elapsed, l.createdOn)

			item, err := attributevalue.MarshalMap(dl)
			if err != nil {
				return fmt.Errorf("error marshalling channel log: %w", err)
			}
			writeReqs[i] = dytypes.WriteRequest{PutRequest: &dytypes.PutRequest{Item: item}}
		}

		_, err := rt.Dynamo.Client.BatchWriteItem(ctx, &dynamodb.BatchWriteItemInput{
			RequestItems: map[string][]dytypes.WriteRequest{rt.Dynamo.TableName("ChannelLogs"): writeReqs},
		})
		if err != nil {
			return fmt.Errorf("error writing channel logs: %w", err)
		}
	}

	attached := make([]*stChannelLog, 0, len(logs))
	unattached := make([]*dbChannelLog, 0, len(logs))

	for _, l := range logs {
		if l.attached {
			// if log is attached to a call or message, only write to storage
			attached = append(attached, &stChannelLog{
				UUID:        l.uuid,
				Type:        l.type_,
				HTTPLogs:    l.httpLogs,
				Errors:      l.errors,
				ElapsedMS:   int(l.elapsed / time.Millisecond),
				CreatedOn:   l.createdOn,
				ChannelUUID: l.channel.UUID(),
			})
		} else {
			// otherwise write to database so it's retrievable
			unattached = append(unattached, &dbChannelLog{
				UUID:      l.uuid,
				ChannelID: l.channel.ID(),
				Type:      l.type_,
				HTTPLogs:  jsonx.MustMarshal(l.httpLogs),
				Errors:    jsonx.MustMarshal(l.errors),
				IsError:   l.isError(),
				CreatedOn: l.createdOn,
				ElapsedMS: int(l.elapsed / time.Millisecond),
			})
		}
	}

	if len(attached) > 0 {
		uploads := make([]*s3x.Upload, len(attached))
		for i, l := range attached {
			uploads[i] = &s3x.Upload{
				Bucket:      rt.Config.S3LogsBucket,
				Key:         l.path(),
				ContentType: "application/json",
				Body:        jsonx.MustMarshal(l),
				ACL:         s3types.ObjectCannedACLPrivate,
			}
		}
		if err := rt.S3.BatchPut(ctx, uploads, 32); err != nil {
			return fmt.Errorf("error writing attached channel logs to storage: %w", err)
		}
	}

	if len(unattached) > 0 {
		err := BulkQuery(ctx, "insert channel log", rt.DB, sqlInsertChannelLog, unattached)
		if err != nil {
			return fmt.Errorf("error inserting unattached channel logs: %w", err)
		}
	}

	return nil
}
